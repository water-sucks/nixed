#!/usr/bin/env bash

# A stripped-down, modified version of nerdfetch
# that fits in with the darkrose colorscheme.
# This is much faster and only works for bash
# and zsh, the only shells I use on these systems.

## OS/KERNEL DETECTION

ostype="$(uname)"

kernel="$(uname -sr | cut -d'-' -f1-3)"
case $ostype in
"Linux"*)
  host="$(cat /proc/sys/kernel/hostname)"
  . /etc/os-release
  os="$PRETTY_NAME"
  ;;
"Darwin"*)
  host="$(hostname -f | sed -e 's/^[^.]*\.//')"
  while IFS='<>' read -r _ _ line _; do
    case $line in
    ProductVersion)
      IFS='<>' read -r _ _ mac_version _
      break
      ;;
    esac
  done </System/Library/CoreServices/SystemVersion.plist
  os="macOS $mac_version"
  ;;
*)
  os="Idk"
  host="host"
  ;;
esac

## UPTIME DETECTION

case $ostype in
"Linux")
  IFS=. read -r s _ </proc/uptime
  ;;
*)
  s=$(sysctl -n kern.boottime)
  s=${s#*=}
  s=${s%,*}
  s=$(($(date +%s) - s))
  ;;
esac
d="$((s / 60 / 60 / 24))"
h="$((s / 60 / 60 % 24))"
m="$((s / 60 % 60))"
# Plurals
[ "$d" -gt 1 ] && dp=s
[ "$h" -gt 1 ] && hp=s
[ "$m" -gt 1 ] && mp=s
[ "$s" -gt 1 ] && sp=s
# Hide empty fields.
[ "$d" = 0 ] && d=
[ "$h" = 0 ] && h=
[ "$m" = 0 ] && m=
[ "$m" != "" ] && s=
# Make the output of uptime smaller.
[ "$d" ] && uptime="$d day$dp, "
[ "$h" ] && uptime="$uptime$h hour$hp, "
[ "$m" ] && uptime="$uptime$m min$mp"
[ "$s" ] && uptime="$uptime$s sec$sp"
uptime=${uptime%, }

## SHELL DETECTION

shell="$(basename "$SHELL")"

case $shell in
"zsh")
  shell="$(zsh --version | cut -d" " -f1-2)"
  ;;
"bash")
  shell="bash $BASH_VERSION"
  ;;
esac

## RAM DETECTION

case $ostype in
"Linux")
  while IFS=':k ' read -r key val _; do
    case $key in
    MemTotal)
      mem_used=$((mem_used + val))
      mem_full=$val
      ;;
    Shmem) mem_used=$((mem_used + val)) ;;
    MemFree | Buffers | Cached | SReclaimable) mem_used=$((mem_used - val)) ;;
    esac
  done </proc/meminfo
  mem_used=$((mem_used / 1024))
  mem_full=$((mem_full / 1024))
  ;;
"Darwin"*)
  mem_full=$(($(sysctl -n hw.memsize) / 1024 / 1024))
  while IFS=:. read -r key val; do
    case $key in
    *' wired'* | *' active'* | *' occupied'*)
      mem_used=$((mem_used + ${val:-0}))
      ;;
    esac
  done <<-EOF
  "$(vm_stat)"
EOF
  mem_used=$((mem_used * 4 / 1024))
  ;;
*)
  mem_full="idk"
  mem_used="idk"
  ;;
esac
memstat="$mem_used/$mem_full MB"
if which expr >/dev/null 2>&1; then
  mempercent="($(expr "$(expr "$mem_used" \* 100 / "$mem_full")")%)"
fi

## COLORS

bold='[1m'
red='[31m'
orange='[33m'
magenta='[35m'
white='[37m'
grey='[90m'
reset='[0m'

nc="$reset$bold$red"
c0="$reset$grey"
c1="$reset$white"
c2="$reset$orange"

## OUTPUT

# temp:

cat <<EOF
${c0}      ___
${c0}     (${c1}.. ${c0}\    ${c2}${USER}${magenta}@${reset}${nc}${host}${reset}
${c0}     (${c2}<> ${c0}|    ${c1}ï…¼ - ${red}OS: ${c1}${os}${reset}
${c0}    /${c1}/  \\ ${c0}\\   ${c1}îˆº - ${red}Kernel: ${c1}${kernel}${reset}
${c0}   ( ${c1}|  | ${c0}/|  ${c1}ï™µ - ${red}Uptime: ${c1}${uptime}${reset}
${c2}  _${c0}/\\ ${c1}__)${c0}/${c2}_${c0})  ${c1}îž• - ${red}Shell: ${c1}${shell}${reset}
${c2}  \/${c0}-____${c2}\/${reset}   ${c1}ï¡š - ${red}Memory: ${c1}${RAM}${memstat} ${mempercent}
EOF
