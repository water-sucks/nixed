From d74c099083487783af7254cb55780ffb20100e53 Mon Sep 17 00:00:00 2001
From: s0nny7 <nneovv@gmail.com>
Date: Wed, 2 Jun 2021 23:52:06 +0800
Subject: [PATCH] fix shadow for rounded window

---
 src/backend/backend.c | 120 ++++++++++++++++++++++--------------------
 1 file changed, 64 insertions(+), 56 deletions(-)

diff --git a/src/backend/backend.c b/src/backend/backend.c
index 9859d2d4..596c7bc9 100644
--- a/src/backend/backend.c
+++ b/src/backend/backend.c
@@ -188,6 +188,70 @@ void paint_all_new(session_t *ps, struct managed_win *t, bool ignore_damage) {
 			                          &reg_paint_in_bound, &reg_visible);
 		}
 
+
+		// Draw shadow on target
+		if (w->shadow) {
+			assert(!(w->flags & WIN_FLAGS_SHADOW_NONE));
+			// Clip region for the shadow
+			// reg_shadow \in reg_paint
+			auto reg_shadow = win_extents_by_val(w);
+			pixman_region32_intersect(&reg_shadow, &reg_shadow, &reg_paint);
+			if (!ps->o.wintype_option[w->window_type].full_shadow) {
+				if (w->corner_radius > 0) {
+					auto reg_bound_no_corner = win_get_bounding_shape_global_without_corners_by_val(w);
+					pixman_region32_subtract(&reg_shadow, &reg_shadow, &reg_bound_no_corner);
+					pixman_region32_fini(&reg_bound_no_corner);
+				} else {
+					pixman_region32_subtract(&reg_shadow, &reg_shadow, &reg_bound);
+				}
+			}
+
+			// Mask out the region we don't want shadow on
+			if (pixman_region32_not_empty(&ps->shadow_exclude_reg)) {
+				pixman_region32_subtract(&reg_shadow, &reg_shadow,
+				                         &ps->shadow_exclude_reg);
+			}
+
+			if (ps->o.xinerama_shadow_crop && w->xinerama_scr >= 0 &&
+			    w->xinerama_scr < ps->xinerama_nscrs) {
+				// There can be a window where number of screens is
+				// updated, but the screen number attached to the windows
+				// have not.
+				//
+				// Window screen number will be updated eventually, so
+				// here we just check to make sure we don't access out of
+				// bounds.
+				pixman_region32_intersect(
+				    &reg_shadow, &reg_shadow,
+				    &ps->xinerama_scr_regs[w->xinerama_scr]);
+			}
+
+			if (ps->o.transparent_clipping) {
+				// ref: <transparent-clipping-note>
+				pixman_region32_intersect(&reg_shadow, &reg_shadow,
+				                          &reg_visible);
+			}
+
+			assert(w->shadow_image);
+			if (w->opacity == 1) {
+				ps->backend_data->ops->compose(
+				    ps->backend_data, w, w->shadow_image, w->g.x + w->shadow_dx,
+				    w->g.y + w->shadow_dy, &reg_shadow, &reg_visible);
+			} else {
+				auto new_img = ps->backend_data->ops->copy(
+				    ps->backend_data, w->shadow_image, &reg_visible);
+				ps->backend_data->ops->image_op(
+				    ps->backend_data, IMAGE_OP_APPLY_ALPHA_ALL, new_img,
+				    NULL, &reg_shadow, (double[]){w->opacity});
+				ps->backend_data->ops->compose(
+				    ps->backend_data, w, new_img, w->g.x + w->shadow_dx,
+				    w->g.y + w->shadow_dy, &reg_shadow, &reg_visible);
+				ps->backend_data->ops->release_image(ps->backend_data, new_img);
+			}
+			pixman_region32_fini(&reg_shadow);
+		}
+
+
 		// Store the window background for rounded corners
 		// If rounded corners backup the region first
 		if (w->corner_radius > 0) {
@@ -274,62 +338,6 @@ void paint_all_new(session_t *ps, struct managed_win *t, bool ignore_damage) {
 			}
 		}
 
-		// Draw shadow on target
-		if (w->shadow) {
-			assert(!(w->flags & WIN_FLAGS_SHADOW_NONE));
-			// Clip region for the shadow
-			// reg_shadow \in reg_paint
-			auto reg_shadow = win_extents_by_val(w);
-			pixman_region32_intersect(&reg_shadow, &reg_shadow, &reg_paint);
-			if (!ps->o.wintype_option[w->window_type].full_shadow) {
-				pixman_region32_subtract(&reg_shadow, &reg_shadow, &reg_bound);
-			}
-
-			// Mask out the region we don't want shadow on
-			if (pixman_region32_not_empty(&ps->shadow_exclude_reg)) {
-				pixman_region32_subtract(&reg_shadow, &reg_shadow,
-				                         &ps->shadow_exclude_reg);
-			}
-
-			if (ps->o.xinerama_shadow_crop && w->xinerama_scr >= 0 &&
-			    w->xinerama_scr < ps->xinerama_nscrs) {
-				// There can be a window where number of screens is
-				// updated, but the screen number attached to the windows
-				// have not.
-				//
-				// Window screen number will be updated eventually, so
-				// here we just check to make sure we don't access out of
-				// bounds.
-				pixman_region32_intersect(
-				    &reg_shadow, &reg_shadow,
-				    &ps->xinerama_scr_regs[w->xinerama_scr]);
-			}
-
-			if (ps->o.transparent_clipping) {
-				// ref: <transparent-clipping-note>
-				pixman_region32_intersect(&reg_shadow, &reg_shadow,
-				                          &reg_visible);
-			}
-
-			assert(w->shadow_image);
-			if (w->opacity == 1) {
-				ps->backend_data->ops->compose(
-				    ps->backend_data, w, w->shadow_image, w->g.x + w->shadow_dx,
-				    w->g.y + w->shadow_dy, &reg_shadow, &reg_visible);
-			} else {
-				auto new_img = ps->backend_data->ops->copy(
-				    ps->backend_data, w->shadow_image, &reg_visible);
-				ps->backend_data->ops->image_op(
-				    ps->backend_data, IMAGE_OP_APPLY_ALPHA_ALL, new_img,
-				    NULL, &reg_visible, (double[]){w->opacity});
-				ps->backend_data->ops->compose(
-				    ps->backend_data, w, new_img, w->g.x + w->shadow_dx,
-				    w->g.y + w->shadow_dy, &reg_shadow, &reg_visible);
-				ps->backend_data->ops->release_image(ps->backend_data, new_img);
-			}
-			pixman_region32_fini(&reg_shadow);
-		}
-
 		// Set max brightness
 		if (ps->o.max_brightness < 1.0) {
 			ps->backend_data->ops->image_op(
